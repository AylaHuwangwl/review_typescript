# Day03 作业布置

## 一. 完成课堂所有的代码









## 二. 什么是TypeScript的抽象类？抽象类有什么作用？

**抽象类有如下的特点：**

- 抽象类是使用abstract声明的类；

- 抽象类是不能被实例的话（也就是不能通过new创建）

- 抽象方法必须被子类实现，否则该类必须是一个抽象类；
- 抽象方法，必须存在于抽象类中；



抽象类有什么作用:

- 抽象类是用来捕捉子类的通用特性的，是被用来创建继承层级里子类的模板。
- 现实中有些父类中的方法确实没有必要写，因为各个子类中的这个方法肯定会有不同；
- 而写成抽象类，这样看代码时，就知道这是抽象方法，而知道这个方法是在子类中实现的，有提示作用。



## 三.  什么是类类型？类类型具有什么样的特点？

类的作用和类类型:

- 类可以创建类对应的实例对象
- 类本身可以作为这个实例的类型, 即作为类类型用
- 类也可以当中有一个构造签名的函数

特点

- 可以作为类使用, 也是可以作为类类型使用
- 类也可以当中有一个构造签名的函数



## 四. 接口和抽象类有什么区别（面试题，特别是Java程序员面试的时候）



接口和抽象类的区别：

（1）抽象类可以有构造方法，接口中不能有构造方法。

（2）抽象类中可以有普通成员变量，接口中没有普通成员变量

（3）抽象类中可以包含静态方法，接口中不能包含静态方法

（4） 一个类可以实现多个接口，但只能继承一个抽象类。

（5）接口可以被多重实现，抽象类只能被单一继承

（6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法

 

接口和抽象类的相同点：

(1) 都可以被继承

(2) 都不能被实例化

(3) 都可以包含方法声明

(4) 派生类必须实现未实现的方法



## 五. 什么**严格的字面量赋值检测**，在行为上有什么特点？

严格的字面量赋值检测

- 对于对象的字面量赋值,  每个对象字面量最初都被认为是“新鲜的（fresh）”

-  对于新鲜的字面量, 会进行严格的类型检测. 必须完全满足类型的要求(不能有多余的属性)

- 当类型断言或对象字面量的类型扩大时，新鲜度会消失。

  

## 六. 什么是泛型？泛型有什么作用，如何使用？

什么是泛型

- 软件工程的主要目的是构建不仅仅明确和一致的API，还要让你的代码具有很强的可重用性
- 比如 我们可以通过函数来封装一些API，通过传入不同的函数参数，让函数帮助我们完成不同的操作
- 对于函数参数的类型进行参数化, 就是泛型的体现
- 泛型除了在函数上使用,也通常会在类 或 接口等地方使用

```ts
function foo<T, E>(arg1: T, arg2: E) {

}

foo(10, 20)
foo(10, "abc")
foo<string, { name: string }>("abc", { name: "why" })

export {}

```



## 七. 什么是泛型约束和泛型条件？在开发中如何被使用？

泛型约束

- 有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中
- 这时我们就会这些不同的类型进行一个约束,  这些类型必须具备某些相同的共性

使用

- extends关键字来约束

```ts
// 传入的key类型, obj当中key的其中之一
interface IKun {
  name: string
  age: number
}

type IKunKeys = keyof IKun // "name"|"age"

function getObjectProperty<O, K extends keyof O>(obj: O, key: K){
  return obj[key]
}

const info = {
  name: "why",
  age: 18,
  height: 1.88
}

const name = getObjectProperty(info, "name")

export {}

```



## 八. TypeScript中映射类型有什么特点？如何使用？

映射类型

- 一个类型需要基于另外一个类型，但是你又不想拷贝一份，这个时候可以考虑使用映射类型

- 比如: 大部分内置的工具都是通过映射类型来实现的, 还有大多数类型体操的题目也是通过映射类型完成的

映射类型建立在索引签名的语法上使用

- 映射类型，就是使用了 PropertyKeys 联合类型的泛型；
- 其中 PropertyKeys 多是通过 keyof 创建，然后循环遍历键名创建一个类型

```ts
// TypeScript提供了映射类型: 函数
// 映射类型不能使用interface定义
// Type = IPerson
// keyof = "name" | "age"
type MapPerson<Type> = {
  // 索引类型以此进行使用
  [aaa in keyof Type]: Type[aaa]
}

interface IPerson {
  name: string
  age: number
}

type NewPerson = MapPerson<IPerson>
export {}

```







































































































